---
title: "Diversity analysis"
date: "`r Sys.time()`"
bibliography: mixed.bib
---

This is an attempt at a streamlined and yet complete, relatively *a priori*/non-
snooped model analysis. **Note** that this version is an overhaul, with some missing components from the older results: see `MixedEffects_older.Rmd` ...

Some parts of the analysis have been moved into separate `.R` files: the overall workflow is

![](make.png)

(`mmd_procdata` is out of date: Enric has processing machinery to
extract lat/long of centroid of largest polygon (?) (`x`/`y` in the data set) and area ...)

```{r get_utils}
source("mmd_utils.R")
source("gamm4_utils.R")
```

Packages used/versions:
```{r load_packages,message=FALSE}
load_all_pkgs()
theme_set(theme_bw())
zmargin <- theme(panel.spacing=grid::unit(0,"lines"))
zmarginx <- theme(panel.spacing.x=grid::unit(0,"lines"))
library('pander')  ## for tables
sapply(pkgList,function(x) format(packageVersion(x)))
```

Note that you now need the *development* version of `lme4`, i.e.
`devtools::install_github("lme4/lme4")`.

```{r knitr_setup,echo=FALSE}
library(knitr)
opts_chunk$set(error=FALSE)
```

Data from Enric (includes area and lat/long coordinates):
```{r get_data,cache=TRUE}
L <- load("ecoreg.RData")
```

Limit all observations with all predictor variables > 0 and no biome 98/99; set `biome` as factor. Log and scale/center variables as appropriate. This leaves us with `r ncol(ecoreg)` variables and
`r nrow(ecoreg)` observations.

## Model fitting

This can now be done semi-automatically (i.e., fit all combinations
of random effects) by using the function `fit_all` from the `mmd_utils.R`
file (sourced above), e.g. `fit_all(response="mbirds_log")`

The `mmd_fitbatch.R` code has already run all
random-effects model combinations for all four response variables,
both with `lme4` and with `gamm4`.  `mmd_reduce.R` has reduced
these to lists with components `sum` (summaries: AIC, singularity, etc.);
`coef` (coefficients); and `pred` (fitted, residuals, etc.).

Load data:

```{r load_data}
load("allfits_sum_lmer.RData")  ## 4 taxa x 27 fits, using lmer
load("allfits_sum_gamm4.RData") ## 4 taxa x 27 fits, using gamm4
```

Table of models with AIC<10:

```{r aic1, results="asis"}
aictab1 <- lme4_res$sum %>%
    filter(AIC<8) %>%
    arrange(taxon,AIC) %>%
    mutate(AIC=round(AIC,1),
           model=shorten_modelname(model))
pander(select(aictab1,-best),emphasize.strong.rows=which(aictab1$best))
```


Best (non-singular) models only:

```{r get_best, results="asis"}
lme4_best_sum <- lme4_res$sum %>%
    filter(best) %>% select(-c(best,singular))
gamm4_best_sum <- gamm4_res$sum %>%
    filter(best) %>% select(-c(best,singular))
all_best_sum <- bind_rows(list(lme4=lme4_best_sum,gamm4=gamm4_best_sum),
                          .id="type")
pander(all_best_sum)
```

Our current strategy is to (1) take the best non-singular model
fitted by `lme4`; (2) find the coefficients of the corresponding `gamm4` model.
(Below, we also try taking the best non-singular `gamm4` model.)

```{r}
lme4_best_models <- select(lme4_best_sum,c(taxon,model))
gamm4_best_models <- select(gamm4_best_sum,c(taxon,model))
## keep only predictions from best models
gamm4_best_pred <- gamm4_res$pred %>%
    right_join(lme4_best_models,by=c("taxon","model"))
```

Fitted vs residual for all four taxa:
```{r fr,message=FALSE,warning=FALSE,fig.width=8,fig.height=4}
ggplot(gamm4_best_pred,aes(.fitted,.resid))+
    geom_point()+geom_smooth()+
    facet_wrap(~taxon,nrow=1)+zmargin
```

A little bit heavy-tailed ...
```{r qq,message=FALSE,warning=FALSE,fig.width=8,fig.height=4}
## https://stackoverflow.com/questions/40598011/how-to-customize-hover-information-in-ggplotly-object
ggqq <- ggplot(gamm4_best_pred,aes(sample=.resid,
                                   colour=biome,
                                   flor_realms=flor_realms))+
    stat_qq()+stat_qq_line(aes(group=taxon))+
    facet_wrap(~taxon,nrow=1)+zmargin
## print(ggqq)
ggplotly(ggqq,tooltip=c("biome","flor_realms"))
```

## coefficient plot of all models tried

For example:

```{r all_coefplot}
gamm4_allcoef <- get_allcoefs(gamm4_res,"plants_log") %>% add_wald_ci
lme4_allcoef <- get_allcoefs(lme4_res,"plants_log") %>% add_wald_ci
gg_allcoef <- ggplot(gamm4_allcoef,aes(estimate,model,colour=singular,shape=singular))+
    ## use point + linerange because some RE are missing std.errors
    geom_point()+
    geom_linerangeh(aes(xmin=lwr,xmax=upr))+
    facet_wrap(~term,scale="free_x")+
    geom_vline(xintercept=0,lty=2)+
    scale_colour_brewer(palette="Set1")+
    zmarginx
```

All `gamm4` coefs for plants:
```{r gamm4_allcoefs_plants,fig.width=10,fig.height=8}
print(gg_allcoef)
```

all `lme4` coefs for plants:
```{r lme4_allcoefs_plants,fig.width=10,fig.height=8}
print(gg_allcoef %+% lme4_allcoef)
```

**to do**: why so many singular now ... ?

**to do**: redo profiling/profile plots,
comparison of Wald/profile CIs (at least for best models ...

Check difference between Wald and likelihood profile
confidence intervals.
In principle profile CIs are more accurate - **if** the computations
have run reliably ... but I would probably be conservative and take
the wider of the two.

Pull out coefs from best models for `lme4`, `gamm4` (from `lme4`-best model),
`gamm4` (from `gamm4`-best model)
```{r}
## lmer-best fits fitted via gamm4
gamm4_best_coef <- gamm4_res$coef %>%
    right_join(lme4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
## gamm4-best fits
gamm4_best2_coef <- gamm4_res$coef %>%
    right_join(gamm4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
fits ## lmer-best fits
lme4_best_coef <- lme4_res$coef %>%
    right_join(lme4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
all_best_coef <- bind_rows(list(lme4=lme4_best_coef,gamm4=gamm4_best_coef,
                                gamm4_2=gamm4_best2_coef),
                           .id="type")
```

**to do**: plot all coefficients including std devs (need to combine group with term for random effects)

Exclude random effects and `NPP_log` (which is large and
significant for all taxa). **Abuse warning**: coloring significant effects.
**Snooping warning**: counting number of sig values for each model type!

```{r coeftab2,message=FALSE,echo=FALSE}
ctx <- all_best_coef %>%
    filter(effect=="fixed" & term!="NPP_log") %>%
    mutate(sig=factor((lwr*upr)>0),
           term=reorder(term,estimate))
pd <- position_dodgev(height=0.33)
ggplot(ctx,aes(estimate,term,group=interaction(term,type),colour=sig,shape=type))+
    geom_linerangeh(aes(xmin=lwr,xmax=upr),position=pd)+
    geom_point(position=pd,fill="white")+
    geom_vline(xintercept=0,lty=2)+
    facet_wrap(~taxon)+  ## ncol=1 might be nice, but too skinny
    labs(x="",y="")+
    scale_colour_manual(values=c("black","orange"),guide=FALSE)+
    scale_shape_manual(values=c(16,21,17))+
    zmargin
```

There are not a lot of effects other than `NPP_log` that are consistently large
and significant; perhaps main effects of fire for birds and mammals.
Amphibians have considerably larger effects (the last three: Feat cv and its
interactions).

Enric and I decided that it was probably best to go with the gamm4-best models,
with some caution expressed about the effects that were marginal. Here are the final(ish?) results, with NPP effects added back in:

```{r coeftab2_gamm4only,message=FALSE,echo=FALSE}
ctx <- gamm4_best2_coef %>%
    filter(effect=="fixed") %>% 
    mutate(sig=factor((lwr*upr)>0),
           term=reorder(term,estimate))
ggplot(ctx,aes(estimate,term,colour=sig))+
    geom_linerangeh(aes(xmin=lwr,xmax=upr))+
    geom_point(position=pd,fill="white")+
    geom_vline(xintercept=0,lty=2)+
    facet_wrap(~taxon)+  ## ncol=1 might be nice, but too skinny
    labs(x="",y="")+
    scale_colour_manual(values=c("black","orange"),guide=FALSE)+
    zmargin
```



## Plotting functions

Load best non-singular gamm4 fits:

```{r}
load("bestmodels_gamm4.RData")
names(best_models)
```

`plotfun()` takes arguments:

- `model`: fitted model
- `xvar` ("NPP_log"): x-variable
- `auxvar` ("Feat_cv_sv"): auxiliary variable (e.g. for examining interactions)
- `respvar` (equal to model response by default): response variable
- `aux_quantiles`: (0.1, 0.5, 0.9) quantiles of auxiliary variable to predict
- `pred_lower_lim` (-3) : lower cut off values (log scale)
- `data` (ecoreg)
- `re.form` (NA) which RE to include in *predictions* (default is none)

```{r predplot,fig.width=10,fig.height=8,warning=FALSE}
ggplot1 <- plotfun(best_models[[1]])
print(ggplot1)
```

or via `ggplotly()`:
```{r ggpredplot,warning=FALSE}
ggplotly(ggplot1)
```

Partial residuals (not working yet):

```{r eval=FALSE}
fix_NAs <- function(rem,model) {
    if (!is.null(nastuff <- attr(model.frame(model),"na.action"))) {
        return(napredict(nastuff,rem))
    } else return(rem)
}
rem1 <- fix_NAs(remef(best_models[[1]]$mer,ran="all"),best_models[[1]])
if (length(rem1)==nrow(ecoreg)) {
    ## if it worked ...
    ecoreg$rem1 <- rem1
    ## update previous plot:
    plotfun(best_model,respvar="rem1")
}
```

## $R^2$ across taxa

Only a few effects have partial $R^2$ values of more than a few percent:
NPP (of course), fire (for mammals and ?birds?), and fire CV (for amphibians).
Everything else is going to be pretty subtle (provided of course that
we trust this particular way of estimating $R^2$).

```{r rsq_calc,cache=TRUE}
all_rsq <- bind_rows(lapply(best_models,
                            function(x) r2beta(x$mer)),.id="taxon") %>%
    mutate(Effect=as.character(Effect),
           Effect=gsub("^X","",Effect),
           Effect=reorder(factor(Effect),Rsq))           
```

```{r rsq_plot}
rsqplot <- ggplot(all_rsq,aes(Rsq,Effect,colour=taxon,shape=taxon))+
    geom_pointrangeh(aes(xmin=lower.CL,xmax=upper.CL),
                   position=position_dodgev(height=0.5))+
    scale_colour_brewer(palette="Dark2")+
    scale_x_log10(limits=c(1e-2,1),oob=scales::squish)+
    labs(y="")
print(rsqplot)
```

## to do

- restructure to allow the rest of the stuff (restricted fits)
- check on singularity calcs
