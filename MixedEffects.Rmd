---
title: "Diversity analysis"
date: "`r Sys.time()`"
bibliography: mixed.bib
output:
  html_document:
    toc: true
---

This is an attempt at a streamlined and yet complete, relatively *a priori*/non-
snooped model analysis.

Moritz, Max A., Enric Batllori, and Benjamin M. Bolker. 2023. “The Role of Fire in Terrestrial Vertebrate Richness Patterns.” Ecology Letters 26 (4): 563–74. https://doi.org/10.1111/ele.14177.

- decide on ordering of plots/tables (Area/NPP/Fire/interactions, or by $R^2$ magnitude?)
- document $R^2$ stuff better, remember we need to install BMB's fork of `r2glmm` (for now):

```{r r2glmm, message=FALSE}
if (packageVersion("r2glmm") < "0.1.2.9002") stop("need hacked r2glmm")
remotes::install_github("bbolker/r2glmm")
```


Some parts of the analysis have been moved into separate `.R` files: the overall workflow is

![](make_ME.png)

```{r get_utils}
source("utils.R")
source("gamm4_utils.R")
```

itPackages used/versions:
```{r load_packages,message=FALSE}
load_all_pkgs()
library('pander')  ## for tables
sapply(pkgList,function(x) format(packageVersion(x)))
comb_out <- function(p,fn,...) {
    print(p)
    htmlwidgets::saveWidget(ggplotly(p,...),fn)
}
```

```{r graph_setup}
graphics_setup()
```

```{r knitr_setup,echo=FALSE}
library(knitr)
opts_chunk$set(error=FALSE,dev.args = list(png = list(type = "cairo")))
```

Data from Enric (includes area and lat/long coordinates):
```{r get_data}}
ecoreg <- readRDS("ecoreg.rds")
```

Limit all observations with all predictor variables > 0 and no biome 98/99; set `biome` as factor. Log and scale/center variables as appropriate. This leaves us with `r ncol(ecoreg)` variables and
`r nrow(ecoreg)` observations.

## Model fitting

This can now be done semi-automatically (i.e., fit all combinations
of random effects) by using the function `fit_all` from the `fit_utils.R`
file (sourced above), e.g. `fit_all(response="mbirds_log")`

The `fit_batch.R` code has already run all
random-effects model combinations for all four response variables,
both with `lme4` and with `gamm4`.  `sum_batch.R` reduces
these to lists with components `sum` (summaries: AIC, singularity, etc.);
`coef` (coefficients); and `pred` (fitted, residuals, etc.).

Load data: summaries containing

- `coefs`: coefficients for all models
- `sum`: summaries for all models: `taxon`, `model`, `AIC`, `singular` (singular fit or not?), `df` (number of parameters), `best` is this the "best" (min-AIC non-singular fit for each taxon) model?
- `pred`: predictions for all models

```{r load_data}
lme4_res <- readRDS("allfits_sum_lme4.rds")  ## 4 taxa x 27 fits, using lmer
gamm4_res <- readRDS("allfits_sum_gamm4.rds") ## 4 taxa x 27 fits, using gamm4
```

Table of models with AIC<10:

```{r aic1, results="asis"}
aictab1 <- lme4_res$sum %>%
    filter(AIC<8) %>%
    arrange(taxon,AIC) %>%
    mutate(AIC=round(AIC,1),
           model=shorten_modelname(model))
pander(dplyr::select(aictab1,-best),emphasize.strong.rows=which(aictab1$best))
```


Best (non-singular) models only:

```{r get_best, results="asis"}
get_best <- . %>% .[["sum"]] %>% filter(best) %>% dplyr::select(-c(best,singular))
all_best_sum <- purrr::map_dfr(list(lme4=lme4_res,gamm4=gamm4_res), get_best, .id="type")
pander(all_best_sum)
```

Our current strategy is to (1) take the best non-singular model
fitted by `lme4`; (2) find the coefficients of the corresponding `gamm4` model.
(Below, we also try taking the best non-singular `gamm4` model.)

```{r best_models}
get_best_tm <- . %>% get_best() %>% dplyr::select(taxon, model)
lme4_best_models <- lme4_res %>% get_best_tm()
gamm4_best_models <- gamm4_res %>% get_best_tm()
## keep only predictions from best models
gamm4_best_pred <- gamm4_res$pred %>%
    right_join(lme4_best_models,by=c("taxon","model"))
```

Fitted vs residual for all four taxa:
```{r fr,message=FALSE,warning=FALSE,fig.width=8,fig.height=4}
gg_fr <- ggplot(gamm4_best_pred,aes(.fitted,.resid))+
    geom_point()+geom_smooth()+
    facet_wrap(~taxon,nrow=1)+zmargin
suppressWarnings(print(gg_fr))
```

A little bit heavy-tailed ...
```{r qq,message=FALSE,warning=FALSE,fig.width=8,fig.height=4}
## https://stackoverflow.com/questions/40598011/how-to-customize-hover-information-in-ggplotly-object
ggqq <- ggplot(gamm4_best_pred,aes(sample=.resid,
                                   colour=biome,
                                   flor_realms=flor_realms))+
    stat_qq()+stat_qq_line(aes(group=taxon))+
    facet_wrap(~taxon,nrow=1)+zmargin
suppressWarnings(
    comb_out(ggqq,"ggqq.html",tooltip=c("biome","flor_realms"))
)
```

([dynamic alternative](./ggqq.html))

## coefficient plot of all models tried

For example (was using plants, now birds because we might not be fitting the models for plants):

```{r all_coefplot}
ex <- "mbirds_log"
gamm4_allcoef <- get_allcoefs(gamm4_res,focal_taxon=ex) %>% add_wald_ci()
lme4_allcoef <- get_allcoefs(lme4_res,focal_taxon=ex) %>% add_wald_ci()
gg_allcoef <- ggplot(gamm4_allcoef,aes(estimate,model,colour=singular,shape=singular))+
    ## use point + linerange because some RE are missing std.errors
    geom_point()+
    geom_linerange(aes(xmin=lwr,xmax=upr))+
    facet_wrap(~term,scale="free_x")+
    geom_vline(xintercept=0,lty=2)+
    scale_colour_brewer(palette="Set1")+
    zmargin
```

All `gamm4` coefs for `r ex`:
```{r gamm4_allcoefs_ex,fig.width=10,fig.height=8}
print(gg_allcoef)
```

all `lme4` coefs for `r ex`
```{r lme4_allcoefs_ex,fig.width=10,fig.height=8}
print(gg_allcoef %+% lme4_allcoef)
```

**to do**: why so many singular now ... ?

**to do**: redo profiling/profile plots,
comparison of Wald/profile CIs (at least for best models ...

Check difference between Wald and likelihood profile
confidence intervals.
In principle profile CIs are more accurate - **if** the computations
have run reliably ... but I would probably be conservative and take
the wider of the two.

Pull out coefs from best models for `lme4`, `gamm4` (from `lme4`-best model),
`gamm4` (from `gamm4`-best model)
```{r best_model_coefs}
## lmer-best fits fitted via gamm4
gamm4_best_coef <- gamm4_res$coef %>%
    right_join(lme4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
## gamm4-best fits
gamm4_best2_coef <- gamm4_res$coef %>%
    right_join(gamm4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
## lmer-best fits
lme4_best_coef <- lme4_res$coef %>%
    right_join(lme4_best_models,by=c("taxon","model")) %>%
    add_wald_ci %>% drop_intercept
all_best_coef <- bind_rows(list(lme4=lme4_best_coef,gamm4=gamm4_best_coef,
                                gamm4_2=gamm4_best2_coef),
                           .id="type")
```

**to do**: plot all coefficients including std devs (need to combine group with term for random effects)

Exclude random effects and `NPP_log_sc` (which is large and
significant for all taxa). **Abuse warning**: coloring significant effects.
**Snooping warning**: counting number of sig values for each model type!

```{r coeftab2,message=FALSE,echo=FALSE}
ctx <- all_best_coef %>%
    filter(effect=="fixed" & term!="NPP_log_sc") %>%
    mutate(sig=factor((lwr*upr)>0),
           term=reorder(term,estimate))
pd <- position_dodgev(height=0.33)
ggplot(ctx,aes(estimate,term,
               group=interaction(term,type),colour=sig,shape=type))+
    geom_linerange(aes(xmin=lwr,xmax=upr),position=pd)+
    geom_point(position=pd,fill="white")+
    geom_vline(xintercept=0,lty=2)+
    facet_wrap(~taxon)+  ## ncol=1 might be nice, but too skinny
    labs(x="",y="")+
    scale_colour_manual(values=c("black","orange"),guide=FALSE)+
    scale_shape_manual(values=c(16,21,17))+
    zmargin
```

There are not a lot of effects other than `NPP_log_sc` that are consistently large
and significant; perhaps main effects of fire for birds and mammals.
Amphibians have considerably larger effects (the last three: Feat cv and its
interactions).

Enric and I decided that it was probably best to go with the gamm4-best models,
with some caution expressed about the effects that were marginal. Here are the final(ish?) results, with NPP effects added back in:

```{r coeftab2_gamm4only,message=FALSE,echo=FALSE,fig.width=8,fig.height=3}
ctx <- (gamm4_best2_coef
    %>% filter(effect=="fixed",taxon!="plants_log")
    %>% mutate(sig=factor((lwr*upr)>0)
             , term_orig=term
             , term=trans_labs(as.character(term))
             , term=reorder(factor(term),estimate)
             , taxon=factor(taxon,
                            levels=paste0(names(auto_lab_text_nounits),"_log"),
                            labels=auto_lab_text_nounits))
)

## RESCALE coefficients:
## coef <- coef*attr(ecoreg$NPP_log_sc,"scaled:scale")

ggplot(ctx,aes(estimate,term,colour=sig))+
    geom_linerangeh(aes(xmin=lwr,xmax=upr))+
    geom_point(position=pd,fill="white")+
    geom_vline(xintercept=0,lty=2)+
    facet_wrap(~taxon)+  ## ncol=1 might be nice, but too skinny
    labs(x="",y="")+
    scale_colour_manual(values=c("black","orange"),guide=FALSE)+
    zmargin +
    theme(axis.text.x=element_text(size=6))
ggsave(file="coeftab.png",width=8,height=3)
```

We can rescale parameters: if the original regression fitted
```
b0 + b1s*(x1/sd1) + b2s*(x2/sd2) + b3s*(x1/sd1)*(x2/sd2)
```
and I want to rescale to the equivalent of `b0 + b1*x1 + b2*x2 + b3*x1*x2` then
I need to multiply by *all* of the corresponding standard deviations: e.g. `b3=b3s*sd1*sd2`


```{r ctx_rescaled, echo=FALSE}
rescale_fun <- function(x, name) {
    ss <- strsplit(name,":")[[1]]
    for (s in ss) {
        sc <- attr(ecoreg[[s]],"scaled:scale") ## sd of original variable
        if (is.null(sc)) stop("uh-oh, ",s," has no scale")
        x <- x*sc
    }
    return(x)
}
## %x% is the general R syntax for an operator (*,+,-,^,**,:)
## %*% is matrix multiplication, %o% outer product, %% is modulus, %/% is integer division
## you can define any other operator by surrounding it by %
## tidyverse uses %>%
## debug(rescale_fun)
## rescale_fun(2.5,name="NPP_log_sc:Feat_log_sc")
ctx_rescaled <- ctx
for (v in c("estimate","lwr","upr")) {
    ctx_rescaled[[v]] <-
        purrr::map2_dbl(ctx_rescaled[[v]], ctx$term_orig, rescale_fun)
}
```

Put in original order:

```{r ctx_rescaled_plot,fig.width=8,fig.height=3,echo=FALSE}
## 
std_order <- c("Area","NPP","NPP CV","Fire","Fire CV")
## create interaction terms
oo <- outer(std_order[-1],std_order[-1],paste,sep=":")
std_order2 <- c(std_order,oo[upper.tri(oo)]) ## append interactions to main effects
## fix reordering of interaction
ctx_rescaled$term <- replace_value_chr(ctx_rescaled$term,
                                       "Fire:NPP CV","NPP CV:Fire")
ctx_rescaled$term <- factor(ctx_rescaled$term, levels=rev(std_order2))
ggplot(ctx_rescaled,aes(estimate,term,colour=sig))+
    geom_linerangeh(aes(xmin=lwr,xmax=upr))+
    geom_point(position=pd,fill="white")+
    geom_vline(xintercept=0,lty=2)+
    facet_wrap(~taxon) +
    labs(x="",y="")+
    scale_colour_manual(values=c("black","orange"),guide=FALSE)+
    zmargin +
    theme(axis.text.x=element_text(size=6))
ggsave(file="coeftab2.png",width=8,height=4)
```
```{r est_tab,results="asis",echo=FALSE}
(ctx_rescaled
    ## reverse order - now top to bottom
    %>% mutate(across(term, ~factor(.,levels=rev(levels(.)))))
    %>% dplyr::select(taxon,term,estimate,lwr,upr)
    %>% arrange(term,taxon)
    %>% mutate(est=sprintf("%1.2g (%1.2g, %1.2g)",estimate,lwr,upr))
    %>% dplyr::select(taxon, term, est)
    %>% pivot_wider(names_from=taxon,values_from=est)
    %>% knitr::kable()
)
```

## Plotting functions

Load best non-singular gamm4 fits:

```{r load_bestmodels_gamm4}
best_models <- readRDS("bestmodels_gamm4.rds")
names(best_models)
```

```{r get_allfits}
allfits_lme4 <- readRDS("allfits_lme4.rds")
best_models_lme4 <- apply(lme4_best_models, 1,
                          function(r) {
                            allfits_lme4[[r[["taxon"]]]][[r[["model"]]]]
                          })
names(best_models_lme4) <- names(allfits_lme4)[1:3] ## skip plants_log
```

`plotfun()` takes arguments:

- `model`: fitted model
- `xvar` ("NPP_log_sc"): x-variable
- `auxvar` ("Feat_cv_sv"): auxiliary variable (e.g. for examining interactions)
- `respvar` (equal to model response by default): response variable
- `aux_quantiles`: (0.1, 0.5, 0.9) quantiles of auxiliary variable to predict
- `pred_lower_lim` (-3) : lower cut off values (log scale)
- `data` (ecoreg)
- `re.form` (NA) which RE to include in *predictions* (default is none)

```{r predplot,fig.width=10,fig.height=8,warning=FALSE}
bm <- best_models[[ex]]
p1A <- plotfun(bm)+nolegend
p1B <- plotfun(bm,backtrans=TRUE)+nolegend
p1C <- plotfun(bm,backtrans=TRUE,log="xy")+nolegend
cowplot::plot_grid(p1A,p1B,p1C,labels="auto")
```

This plot shows (a) observed points and fit on log scale (using "fire eaten" as aux variable, i.e. lines show predictions for 0.1/0.5/0.9 quantiles of fire-eaten); (b) points and back-transformed predictions; (c) the same, but with a constrained scale; (d) back-transformed preds with scaled *axes* (`scale_*_log10()`) (scale also constrained)

Partial residuals:

```{r test_backtrans}
p1D <- plotfun(bm,respvar="partial_res")+nolegend
p1E <- plotfun(bm,respvar="partial_res",backtrans=TRUE)+nolegend
p1F <- plotfun(bm,respvar="partial_res",backtrans=TRUE,log="xy")+nolegend
partial_res_plot <- cowplot::plot_grid(p1D,p1E,p1F,labels="auto")
print(partial_res_plot)
```

## $R^2$ across taxa

Only a few effects have partial $R^2$ values of more than a few percent:
NPP (of course), fire (for mammals and ?birds?), and fire CV (for amphibians).
Everything else is going to be pretty subtle (provided of course that
we trust this particular way of estimating $R^2$).

```{r rsq_calc, cache=TRUE, echo=FALSE}
get_rsq <- function(taxon, models = best_models, df = NULL) {
  model <- models[[taxon]]
  if (is(model, "gamm4")) {
    if (is.null(df)) df <- model.frame(model$mer)
    ## hack area (not sure why other vars are already present
    ## in unmunged-name form??
    if (!"area_km2_log_sc" %in% names(df))
      df$area_km2_log_sc <- df$X.area_km2_log_sc
    names(df)[1] <- taxon
    formula <- reformulate(c("(NPP_log_sc+NPP_cv_sc + Feat_log_sc+Feat_cv_sc)^2", "area_km2_log_sc"), response = taxon)
    mm <- model.matrix(formula, df)
    r2beta(models[[taxon]], formula=formula, random=NULL, method="kr", data=df,
           partial.terms=colnames(mm)[-1])
  } else {
    r2beta(models[[taxon]], method="kr", partial = TRUE)
  }
}

nn <- names(best_models)
names(nn) <- nn ## ugh, for map_dfr
all_rsq <- purrr::map_dfr(nn, get_rsq, .id="taxon")
mutate_rsq <- (.  
    %>% as_tibble()
    %>% filter(taxon !="plants_log")
    %>%  mutate(Effect=as.character(Effect),
                Effect=gsub("^X","",Effect),
                Effect=trans_labs(Effect),
                Effect=replace_value_chr(Effect, "Fire:NPP CV","NPP CV:Fire"),
                Effect=factor(Effect,levels=rev(c("Model",std_order2)))
                )
    %>% dplyr::select(taxon,Effect,Rsq,upper.CL,lower.CL)
)

all_rsq2 <- all_rsq %>% mutate_rsq()
```

```{r lme4_rq_calc, cache=TRUE, warning=FALSE}
## try with plain old lme4 so we don't need hacked gamm4 stuff ...
nn4 <- names(best_models_lme4)
names(nn4) <- nn4
r2beta(best_models_lme4[["mamph_log"]], method="kr", partial = TRUE)
all_rsq_lme4 <- purrr::map_dfr(best_models_lme4,
                               function(n) r2beta(n , method="kr",
                                                   partial = TRUE),
                               .id="taxon")
all_rsq_lme4_2 <- all_rsq_lme4 %>% mutate_rsq()
all_rsq_lme4_sgv <- purrr::map_dfr(best_models_lme4,
                               function(n) r2beta(n , method="sgv",
                                                   partial = TRUE),
                               .id="taxon")
all_rsq_lme4_sgv_2 <- all_rsq_lme4_sgv %>% mutate_rsq()
all_rsq_sgv_2 <- purrr::map_dfr(best_models,
                               function(n) r2beta(n , method="sgv",
                                                   partial = TRUE),
                               .id="taxon") %>% mutate_rsq()

```


```{r rsq_plot}
rsqplot <- ggplot(all_rsq2, aes(Rsq,Effect,colour=taxon,shape=taxon))+
    geom_pointrangeh(aes(xmin=lower.CL,xmax=upper.CL),
                   position=position_dodgev(height=0.5))+
    scale_colour_brewer(palette="Dark2",labels=c("Amphibians","Birds","Mammals"))+
    scale_shape(labels=c("Amphibians","Birds","Mammals"))+
    ## scale_x_log10(limits=c(1e-2,1),oob=scales::squish)+
    labs(y="")
print(rsqplot)
```

Redraw R^2 plot but based on lme4 fits (less chance that my R^2 hacking screwed something up ...); still weird, although slightly differently weird (maybe worse?)

```{r rsq_plot_lme4}
xsc <- scale_x_continuous(limits=c(0,1))
plot_grid(rsqplot %+% all_rsq_lme4_2 + ggtitle("lme4, kr") + xsc,
          rsqplot + ggtitle("gamm4, kr") + xsc,
          rsqplot %+% all_rsq_lme4_sgv_2 + ggtitle("lme4, sgv") + xsc,
          rsqplot %+% all_rsq_sgv_2 + ggtitle("gamm4, sgv") + xsc
          )
ggsave("rsq_comp.png")
```

```{r echo=FALSE, eval=FALSE}
library(ggforce)
bigvals <- c("Model","NPP","Area")
rsqplot + facet_zoom(x=Effect %in% bigvals, zoom.data=Effect %in% bigvals, show.area=FALSE)
```
Plot in two panels:

```{r rsqplot2,message=FALSE,warning=FALSE}
all_rsq2$upper <- with(all_rsq2,Effect %in% c("Model","NPP","Area"))
r1 <- rsqplot %+% subset(all_rsq2,upper) + scale_x_continuous(position="top")
r2 <- rsqplot %+% subset(all_rsq2,!upper)
## facet_wrap doesn't have 'space' argument ...
## rsqplot %+% all_rsq2 +facet_wrap(~upper,ncol=1,scales="free")
## facet_grid doesn't use axes for all facets ...
## rsqplot %+% all_rsq2 +facet_grid(upper~.,scales="free",space="free") +
##    theme(strip.text=element_blank())
## https://cran.r-project.org/web/packages/cowplot/vignettes/shared_legends.html
## FIXME: Warning in get_plot_component(plot, "guide-box"): Multiple components found;
##        returning the first one. To return all, use `return_all = TRUE`.
L <- get_legend(r1)
## stack facets
p1 <- plot_grid(r1
                +labs(x="")
                ## rectangle indicating scale of lower box w/in upper
                + geom_rect(xmin=0,xmax=0.125,ymin=-Inf,ymax=Inf,
                            fill="black",
                            colour=NA,alpha=0.02)
                + theme(legend.position="none"),
                r2+labs(x=expression(R^2)) + theme(legend.position="none"),
                ncol=1,
                align="v",rel_heights=c(0.3,0.7),axis="b")
## add legend
pg <- plot_grid(p1,L,rel_widths=c(2,0.4))
print(pg)
ggsave(pg,file="rsqplot.png")
```

```{r rsqtab, results="asis", echo=FALSE}
rsq_tab <- (.
    ## rename to match coef tab (reuse code)
    %>% rename(term="Effect",lwr="lower.CL",upr="upper.CL",estimate="Rsq")
    %>% mutate(across(term, ~factor(.,levels=rev(levels(.)))))
    %>% dplyr::select(taxon,term,estimate,lwr,upr)
    %>% arrange(term,taxon)
    %>% mutate(est=sprintf("%1.2g (%1.2g, %1.2g)",estimate,lwr,upr))
    %>% dplyr::select(taxon, term, est)
    %>% pivot_wider(names_from=taxon,values_from=est)
    %>% knitr::kable()
)
print(all_rsq2 %>% rsq_tab)
```

What about a combined "fire $R^2$"? "NPP $R^2$?"

```{r cmp_R2_2, echo=FALSE}
special_R2 <- function(model, type="fire") {
  fire_terms <- "(Feat_log_sc * Feat_cv_sc) + (NPP_log_sc + NPP_cv_sc):(Feat_log_sc + Feat_cv_sc)"
  NPP_terms <- "(NPP_log_sc * NPP_cv_sc) + (NPP_log_sc + NPP_cv_sc):(Feat_log_sc + Feat_cv_sc)"
  ## update(formula(best_models[[1]]), as.formula(sprintf(". ~ . - (%s)", fire_terms)))
  terms <- switch(type,
                  fire=fire_terms,
                  NPP=NPP_terms)
  ## ugh
  taxon <- deparse1(formula(model$gam)[[2]])
  df <- model.frame(model$mer)
  names(df)[1] <- taxon
  formula <- reformulate("(NPP_log_sc+NPP_cv_sc + Feat_log_sc+Feat_cv_sc)^2", response = taxon)
  r2beta(model, formula = formula, partial.terms = terms, method="KR", random=NULL,
         data=df)
}

get_taxon_rsq <- function(t) {
  (purrr::map_dfr(
              best_models, .id="taxon", ~ special_R2(., t))
    %>% as_tibble()
    %>% filter(taxon !="plants_log")
    %>% mutate(across(Effect, ~ ifelse(. == "Model", "Model", t)))
    %>% dplyr::select(taxon,Effect,Rsq,upper.CL,lower.CL)
  )
}
```

```{r fn_rsq, cache=TRUE}
tt <- c("fire", "NPP")
fn_rsq <- purrr::map_dfr(setNames(tt,tt), .id="type", get_taxon_rsq)
```


```{r plot_all_Rsq,echo=FALSE,fig.width=10,fig.height=2.75}
fn_rsq  <- fn_rsq %>% mutate(across(Effect, ~ factor(., levels=c("Model","NPP","fire"))))
print(ggplot(fn_rsq,aes(Rsq,taxon, colour=Effect))
      + geom_pointrange(aes(xmin=lower.CL,xmax=upper.CL),
                        position=position_dodge(width=0.25))
      )
```

From @jaeger_r2_2017:

> More specifically, $R^2_{\beta^*}$ measures the multivariate association
> between the outcome and the fixed effects within the context of correlated observations,
> while $R^2_{NSJ(m)}$ measures the proportion of explained variance assuming that unexplained
> variance may be estimated with a scalar and correlation between observations may be ignored.

```{r fire_R2_tab, results="asis",echo=FALSE}
(fn_rsq
  %>% filter(!(Effect=="Model" & type=="fire"))
  %>% mutate(across(Effect, ~ factor(., levels=rev(levels(.)))))
  %>% rsq_tab()
)
```


## Models fitted with only biome and flor_realms

(from `fit_batch.R`): diagonal (independent) random effects
at the biome and flor realm level.
One of the keys here is that the line for each biome is estimated
based on the median values of the other predictors (fire, NPP CV,
area, etc.) for that *particular* biome, not the global median ...

```{r predfun_biome_construct}
allfits_restr_gamm4 <- readRDS("allfits_restr_gamm4.rds")
predList <- lapply(allfits_restr_gamm4,
       predfun,
       auxvar=NULL,grpvar="biome",
       re.form=~(1+NPP_log_sc|biome))
set.focal <- function(n,d) { d$focal <- d[[n]]; return(d) }
predList <- Map(set.focal,names(predList),predList)
predFrame <- bind_rows(predList,.id="taxon")
dList <- setNames(replicate(4,ecoreg,simplify=FALSE),names(predList))
dList <- Map(set.focal,names(dList),dList)
dFrame <- bind_rows(dList,.id="taxon")
```

```{r predfun_biome_plot,warning=FALSE,fig.width=10,fig.height=8}
ggplot(predFrame,aes(x=NPP_log_sc,y=focal,colour=biome))+
    geom_line(lwd=1.5)+
    geom_point(data=dFrame,aes(shape=flor_realms),alpha=0.7)+
    facet_wrap(~taxon)+zmargin+
    labs(y="log diversity")+
    theme(legend.position="bottom")
```

Version with `Feat_log_sc` (main effect of fire) as focal predictor:

```{r predList_fire}
predList_fire <- lapply(allfits_restr_gamm4,
       predfun,
       xvar="Feat_log_sc",
       auxvar=NULL,grpvar="biome",
       re.form=~(1+Feat_log_sc|biome))
predList_fire <- Map(set.focal,names(predList_fire),predList_fire)
predFrame_fire <- bind_rows(predList_fire,.id="taxon")
```

```{r predfun_biome_plot_fire,warning=FALSE,fig.width=10,fig.height=8}
(gpbf1 <- ggplot(predFrame_fire,aes(x=Feat_log_sc,y=focal,colour=biome))+
    geom_line(lwd=1.5)+
    geom_point(data=dFrame,aes(shape=flor_realms),alpha=0.7)+
    facet_wrap(~taxon)+zmargin+
    labs(y="log diversity")+
    theme(legend.position="bottom"))
```

```{r predfun_biome_plot_fire_ribbon,warning=FALSE,fig.width=10,fig.height=8}
gpbf1 + geom_ribbon(colour=NA,aes(ymin=lwr,ymax=upr,group=biome),alpha=0.2)
```

Plot random effects estimates
with $\pm$ 2 SE (these effects do *not* include the effects of
the variation of levels of NPP and fire across biomes/realms; they
represent deviations from the expectation based on the population-level
effects ...)

```{r coefplot_calcs, echo=FALSE}
tt_all_lst <- lapply(allfits_restr_gamm4,
                 function(x) (x$mer
                   %>% tidy(effects="ran_vals")
                   %>% dplyr::select(-effect)
                   %>% filter(group!="Xr", term !="(Intercept)",
                              group!="flor_realms")))
tt_all <- bind_rows(tt_all_lst,.id="taxon")
gg2A <- ggplot(tt_all,aes(x=estimate,y=level,colour=taxon))+
    geom_pointrangeh(aes(xmin=estimate-2*std.error,
                         xmax=estimate+2*std.error),
                     position=position_dodgev(height=0.25))+
    geom_vline(xintercept=0,lty=2,colour="red")+
    theme(panel.spacing.x=grid::unit(0,"lines"))
ggL <- lapply(unique(tt_all$term),
              function(x) {
                tt3 <- tt_all[tt_all$term==x,]
                tt3$level <- reorder(tt3$level,tt3$estimate)
                gg <- (gg2A %+% tt3)+ggtitle(x)+labs(y="")
                return(gg)
              })
```

```{r coefplot_plot,fig.width=8}
do.call(plot_grid,ggL)
ff <- filter(tt_all, taxon=="mbirds_log", group=="biome",term=="NPP_log_sc")
gg2A %+% ff + aes(x=estimate,y=level, colour = NULL)
```

## Test effects

(??? what was I going to do here ???)

## Extract coefficients

In this particular case the effect of NPP only varies across floristic realms,
so the picture isn't especially pretty:

```{r coef_var}
coefs_plants <- merge_coefs(ecoreg,best_models[[1]])
ggplot(coefs_plants,aes(x,y,colour=NPP_log_sc))+
    geom_point()+
    scale_colour_viridis()
```

## No-fire predictions

```{r nofire}
predList_fire <- lapply(best_models,
       predfun,
       auxvar=NULL,grpvar=NULL)
predList_nofire <- lapply(best_models,
       predfun,
       auxvar=NULL,grpvar=NULL,
       exclude_fire=TRUE)
```

##

```{r barplots}
## (ecoreg
##   %>% group_by(biome)
##   %>% summarise(across(area_km2, ~sum(.)/1e6))
##   %>% dplyr::select(biome, area_km2)
##   %>% arrange(area_km2)
## )

shortnames <- data.frame(biome = c("Trop/Subtrop Moist", "Trop/Subtrop Dry", "Trop/Subtrop Conif",
                                   "Temp Broad", "Temp Conif", "Boreal/Taiga", "Trop Grass", "Temp Grass",
                                   "Flood Grass", "Mont Grass", "Tundra", "Medit", "Desert/Shrub", 
                                   "Mangro"),
                         bshort = c('TrMF','TrDF','TrCF','TeBF','TeCF','BorF','TrG','TeG','FlG','MoG','Tund','MedF','Des','Mang'))

e_mean <- (ecoreg
  %>% full_join(shortnames, by = "biome")
  %>% group_by(bshort)
  %>% mutate(across(area_km2, ~ sum(.) / 1e6)) ## set area to **sum** of area (millions of km^2)
  %>% summarise(across(c(NPP_mean, Feat_mean, mamph, mbirds, mmamm, area_km2), ~ mean(., na.rm = TRUE)))
  %>% mutate(across(bshort, ~ reorder(factor(.), NPP_mean)))
  %>% mutate(across(Feat_mean, ~ . * 100)) ## convert to pct
)

## https://stackoverflow.com/questions/56025382/ggrepel-labels-outside-to-the-right-of-ggplot-area/56027661#56027661
## https://stackoverflow.com/questions/12409960/ggplot2-annotate-outside-of-plot
## compute positions for area-stacked chart
e_mean2 <- e_mean %>% arrange(bshort) %>%
  mutate(tot_area = cumsum(area_km2),
         prev_area = c(0, tot_area[1:n()-1]),
         mid = (prev_area+tot_area)/2)

inter <- 1 ## inter-bar spacing
library(ggrepel)
mkplot <- function(var, colour, type="rect", xlab = "", title= "") {
  g1 <- ggplot(e_mean2)
  if (type=="rect") {
    g1 <- g1 + geom_rect(xmin=0, aes(xmax={{var}}, ymin=prev_area+inter, ymax=tot_area-inter),
                         fill = colour) +
      geom_text_repel(x = 0,
                  aes(label = bshort, y = mid), 
                  direction = "y",
                  ## VERY close. TrMF, TeBF are below where I want them
                  hjust = -1.5,
                  vjust = 0,
                  segment.size = 0.2,
                  na.rm = TRUE,
                  force_pull = 100,
                  force = 0.5,
                  min.segment.length = 0.5,
                  xlim = c(-5,5)) +
      coord_cartesian(clip = 'off') +
      theme(plot.margin = margin(t=5.5, r=1, b=5.5, l=50, unit="pt")) +
      ## theme(axis.text.y = element_text(size=7)) ## try to avoid overlapping labels ( + 'inter')
      theme(axis.text.y = element_blank()) ## try to avoid overlapping labels ( + 'inter')
    ylabs <- e_mean2$bshort  ## short names
  } else {
    g1 <- g1 + geom_point(aes(x={{var}}, y = mid), colour = colour, size=3) +
      geom_segment(x=0, aes(xend = {{var}}, y = mid, yend = mid), colour = colour, linewidth=1)
    g1 <- g1 + theme(axis.text.y = element_blank()) +
      theme(plot.margin = margin(t=5.5, r=1, b=5.5, l=1, unit="pt"))
    ylabs <- NULL
  }
  v <- e_mean2[[deparse(substitute(var))]] ## ugh
  g1 +
    scale_y_continuous(breaks=e_mean2$mid, labels=ylabs,
                       limits=c(min(e_mean2$prev_area) - inter, max(e_mean2$tot_area+inter))) +
    scale_x_continuous(limits=c(0,max(v)*1.05), expand=c(0,0)) +
    labs(x=xlab, title= title) +
    theme(axis.title.y = element_blank()) +
    theme(plot.title = element_text(hjust = 0.5))
}

cols <- c("darkolivegreen3", "orangered", "grey80", "grey60", "grey40")
plot_list <- list(
    mkplot(NPP_mean, cols[1], xlab=expression(g~C/m^{2}/year), title="NPP"),
     mkplot(Feat_mean, cols[2], type = "point", xlab="% of NPP", title = "Fire loss"),
     mkplot(mamph, cols[3], type = "point", xlab=expression(species/(10~km^{2})), title="Amphibian\nrichness"),
     mkplot(mbirds, cols[4], type = "point", xlab=expression(species/(10~km^{2})), title="Bird\nrichness"),
     mkplot(mmamm, cols[5], type = "point", xlab=expression(species/(10~km^{2})), title="Mammal\nrichness")
     )

library(patchwork)
## give NPP a little extra space
wrap_plots(plot_list, nrow=1, widths=c(1.2, rep(1,4)))
ggsave("fig2.pdf",width=14, height=8)
ggsave("fig2.svg",width=14, height=8)
```

## Methods description

For analysis, we log-transformed all response and predictor variables except the interannual coefficients of variation.

For ease of interpretation, we scaled and centered all predictor variables for ease of interpretation; this allows parameter estimates to be interpreted as relative effect sizes across predictors with different units, i.e. the expected change in the response (log-diversity) from an increase of 1 standard deviation in the predictor (CITE: Schielzeth 2010). The data were grouped at three levels: biome (e.g. tropical forest), realm (e.g. Neotropics), and their interaction (e.g. Neotropical forests).
	
As fixed-effect (overall, global-scale) predictors, we incorporated ecoregion area (km^2); annual NPP (G C/m^2/year); average fraction of NPP consumed by fire annually (proportion); and the interannual coefficient of variation of NPP and fire losses, as well as the pairwise interactions of all of these predictors except for area. In principle we would also like to allow all the effects of all of these predictors, and their interactions, to vary at all three grouping levels (biome, realm, biome $\times$ realm), and to estimate all of the correlations among them. For example, it would be interesting to know if biomes where diversity was more sensitive to NPP also had diversity that was more sensitive to fire, or realms where diversity was more sensitive to variation in fire were *less* sensitive to variation in NPP. However, the full model with correlated variation at all three levels is very complex; the covariance matrix for each level has 15 parameters (for the covariance matrix of an intercept plus four predictors, we have (5x6)/2=15 independent values in a 5x5 symmetric matrix). This leads to poorly estimated parameters, and often to singular fits where some variances are estimated as zero or correlations as $\pm 1$ (CITE Barr et al 2013, others?). We thus allowed for some simplified versions of the model, either assuming the variation across groups was uncorrelated (5 parameters in a diagonal covariance matrix vs. 15 in an unstructured matrix) or assuming that only the intercept varied across groups (1 parameter). For each taxon we fitted all 27 possible model combinations ((intercept-only, independent, full) $\times$ (biome, realm, biome $\times$ realm)), checked for singularity, and computed the AIC. We selected the non-singular model with the best (lowest) AIC.

## References
